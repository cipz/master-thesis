%!TEX root = ../thesis.tex

% https://en.wikipedia.org/wiki/Kelly_Johnson_(engineer)
% https://en.wikipedia.org/wiki/KISS_principle
\begin{savequote}[40mm]
	\textbf{K}eep\\
	\textbf{I}t\\
	\textbf{S}imple\\
	\textbf{S}tupid
	\qauthor{Kelly Johnson}
\end{savequote}

\chapter{Proposed solution}\label{chapter:proposed_solution}
	
	\textbf{\textcolor{red}{\hl{// To be completed with one or two phrases}}}

	This chapter contains the technical description of the mesh network developed with the FiPy and communicates using LoRa.
	Such mesh network will be referred as ``\textit{Open LoRa Mesh}''.
	Especially such networks is able to accommodate small messages, such as the ones sent by MegaSense, described in Section~\ref{subsec:megasense}.

	Even though it would have been possible to use a simulator, such as ``\textit{The one}''\footnote{ \url{akeranen.github.io/the-one}}, for demonstrating the usefulness of such network, the final project has been realized with Pycom hardware, discussed in Section~\ref{sec:hardware_solution}.
	
	The code created for this project is open sourced and available on GitHub\footnote{ \url{www.github.com/cipz/OpenLoRaMesh}}.
	Such code is better explained later in Section~\ref{sec:software_solution} and its subsections.
	
	\section{Network architecture}\label{sec:architecture}
		
		Before talking about the architecture of the mesh, it is important to understand the one of the MegaSense.
		As can be seen in Figure~\ref{img:megasense_architecture}, since each MegaSense device is made to be carried by a person, devices connect each one to the user's phone.
		The latter then communicates with the MegaSense and, via the application developed by the Computer Science Department at the University of Helsinki, sends the air-quality readings and the GPS location, which has been read by the application from the phone itself, to the servers in the cloud.
		
		Communication between MegaSense and phone is done via BLE, and exchanges data such as sensor readings (like NO2,
		O3, CO, battery percentage, \textit{etc.}) and calibration measurements, in \texttt{JSON} format.
		Thus each device has to be linked to a person's phone, which might enhance the portability of the device, but not its possibility to read data independently if placed in a specific location.
		Such communication resembles the one from devices described in Section~\ref{subsec:commercial_applications}.
		
		\begin{figure}[h]
			\centering
			\includegraphics[width=.75\textwidth]{resources/img/chap5/architecture_megasense}
			\caption{MegaSense architecture}
			\label{img:megasense_architecture}
		\end{figure}
	
		One of the goals Open LoRa Mesh tries to achieve, is to give independence to these devices, so that they can communicate one another and allow information to be passed along between nodes without the aid of a user's phone.
	
		This is why the architecture would evolve from the one in Figure~\ref{img:megasense_architecture} to Figure~\ref{img:openmesh_architecture}: the phone is replaced by a FiPy, which also connects to the MegaSense via BLE, and sends the data acquired from the sensors in the network.
		Nodes communicate with each other via LoRa, detailed in Section~\ref{subsec:lora_lorawan}, and exchange data using mainly \textit{LoRaCTP}, described in Section~\ref{subsec:loractp}.
		
		\begin{figure}[h]
			\centering
			\includegraphics[width=.7\textwidth]{resources/img/chap5/mesh-architecture-1}
			\caption{Open LoRa Mesh architecture}
			\label{img:openmesh_architecture}
		\end{figure}
		
		Each FiPy board represents a node on the network, which in this case is a ``\textit{Flat Wireless Mesh}'', where each node acts both as data provider and as data forwarder.
		Although simple, such network architecture is well known from the previously mentioned, Section~\ref{sec:scalability}, Gupta and Kumar \cite{825799}.
		Besides not scaling well and having the potential to put very high resource constraints, ``\textit{addressing schemes and service discovery would prove to be a major bottleneck against scalability}'' \cite{92000412}.
		
		Despite having these disadvantages, it is important to remind the environment and the number of devices that will be connected in such network.
		Since communication is not frequent and data packets are not large, this network layout can satisfy the MegaSense's requirements for interconnection.

	\section{Open LoRa Mesh Hardware}\label{sec:hardware_solution}
	
		For the development of Open LoRa Mesh, the chosen hardware to replace the phone in the original MegaSense architecture is composed by Pycom's FiPy microcontrollers, along with its shields, like the PyTrack and the PySense.
		A prototype of the MegaSense device was also given from the developers of the project in order to test the connectivity with the Pycom boards and test its capacity to send and receive data from other nodes in the network.
		All devices can be seen together in Figure~\ref{img:irl_picture_1}.
		
		\begin{figure}[h]
			\centering
			\includegraphics[width=\textwidth]{resources/img/chap5/mesh-irl-picture}
			\caption{FiPy with PyTrack, LoRa antenna, GPS antenna and MegaSense prototype}
			\label{img:irl_picture_1}
		\end{figure}
		
		Although the expansion board is important, the FiPy is the one that contains all the chips that allow connectivity, as said in Section~\ref{sec:pycom}.
		After an initial evaluation on the requirements necessary in creating a network for exchanging messages among air quality sensing devices, Pycom's boards have come first considering the numerous possibilities it allows for prototyping.
		
		The exact hardware with which this project has been completed is: four FiPy boards, one PyTrack 2X, one PyTrack, two PySense shields and one MegaSense prototype, Figure~\ref{img:megasense_picture}.
		Pycom boards do not have a USB connection directly on them, so they can be programmed either using a shield or via an UART (Universal Asynchronous Receiver-Transmitter) to USB.
		
		Alternative microcontrollers, such as the Raspberry Pi Pico, Raspberry Pi 4, Arduino Nano 33 BLE Sense, and ESP32 boards have been discard given either their excessive power or their need for multiple expansion shields.
				
	\section{Open LoRa Mesh Software}\label{sec:software_solution}
	
		While the Arduino's C++ dialect divides the code in two main functions, the \texttt{setup()} and \texttt{loop()}, as mentioned in Chapter~\ref{chapter:technologies}, the Pycom boards use two files to separate an initial bootstrap of the board and a main section of the code.
		These two special files are called \texttt{boot.py} and \texttt{main.py} respectively.
		
		The following section explains the algorithms made for this project are delineated and it is shown how they have been implemented.
		Afterwards, the addressing scheme in LoRa, which is important to understand, is described.
		
		The FiPy boards have been programmed using Micropython, and the firmware flashed\footnote{ \textit{Flashing} involves the overwriting of existing firmware or data, contained in EEPROM or flash memory module present in an electronic device, with new data.} on the boards, at the time of writing, is \texttt{v1.16.5}.
		
		\subsection{Algorithms}\label{subsec:algorithms}
	
			% DRAWING AUTOMATA
			% https://latexdraw.com/automata-diagrams-in-latex/
			% https://hayesall.com/blog/latex-automata/
			
			% DRAWING FLOWCHART
			% https://www.overleaf.com/learn/latex/LaTeX_Graphics_using_TikZ%3A_A_Tutorial_for_Beginners_(Part_3)%E2%80%94Creating_Flowcharts

			This section shows in depth how the software works, for more significant building block of the code there are finite-state automata (or FSA) that show the state nodes find themselves in.
			For a graphical reason, each state of the following automata is abbreviated, and, when needed, the full state is described in a table underneath it.
			
			At first an overview of the entire software is presented, then for each important component of the software there is a subsection that describes how it functions and connects to the rest.
			Such vision should allow to understand the system from a broader point of view to a more detailed one, where every function is analyzed.
			
			\newpage
			\subsubsection{Overview of the whole system}
			
				As previously said, the FiPy is divided in two files, \texttt{boot.py} and \texttt{main.py}.
				When the board is powered up, the first file executed is \texttt{boot.py}, which contains the code that either boots the device in a state of listener or continues its normal sequence.
				
				The listener state allows for the device to be used as a station that only sniffs the messages traveling in the air.
				
				Continuing in the normal sequence, thus executing the code in \texttt{main.py}, will allow the node to connect to an existing mesh or to create one, for sending and receiving data afterwards.
			
%				\begin{table}[h]
%					\begin{center}
%						\begin{tabularx}{0.85\textwidth}{@{}|Y|Y|Y|@{}} 
%							\hline
%							State abbreviation & Full state name & State description \\\hline
%							$start$ && \\\hline
%							$s_{0}$ && \\\hline
%							$s_{1}$ && \\\hline
%							$s_{2}$ && \\\hline
%							$s_{3}$ && \\\hline
%						\end{tabularx}
%						\caption{FSA \ref{fsa:fsa_overview} description}
%						\label{table:fsm_main}
%					\end{center}
%				\end{table}
			
%				\begin{figure}
%					\centering
%					
%					\begin{tikzpicture}[node distance=2cm]
%						\node (start) [startstop] {Start};
%						\node (pro1) [process, below of=start] {\texttt{boot()}};
%						\node (dec1) [decision, below of=pro1, yshift=-0.5cm] {\texttt{boot\_mode}};
%						\node (pro2a) [process, below of=dec1, yshift=-0.5cm, xshift=-2cm] {\texttt{main()}};
%						\node (pro2b) [process, below of=dec1, yshift=-0.5cm, xshift=2cm] {\texttt{listen()}};
%					
%						\draw [arrow] (start) -- (pro1);
%						\draw [arrow] (pro1) -- (dec1);
%						\draw [arrow] (dec1) -- node[anchor=east] {\texttt{DEFAULT\_BOOT}} (pro2a);
%						\draw [arrow] (dec1) -- node[anchor=west] {\texttt{PLAIN\_RECEIVER}} (pro2b);
%					\end{tikzpicture}
%					\label{algo_1}
%					\caption{Outline algorithm}
%				\end{figure}
			
			\newpage
			\subsubsection{Boot}
			
				As mentioned earlier, the \texttt{boot.py} file contains the code that is initially executed by the FiPy.
				In the case of Open LoRa Mesh, this code contains the instructions to load a \texttt{config.json} file, which contains the boot mode the device will be initialized in.
				
				The first operation done is to disable Wi-Fi communication and the default blinking (heartbeat) of the FiPy.
				Since when powered up, Fipy's firmware enables Wi-Fi, it can be useful to turn it off because it is not used, also it could draw unnecessary power from the device.

				\begin{lstlisting}
					content
				\end{lstlisting}
				
				During the boot procedure, the board checks the availability of a \texttt{config.json} file on an external SD card and, if present, uses the parameters on such files.
				If not present it checks for such file locally on the flash memory, which contains one with default configurations and is uploaded with the \texttt{*.py} files.

				The configuration file contains the custom parameters that can be used by the board.
				One of these parameters is the \texttt{BOOT\_MODE}, which can either be \texttt{DEFAULT\_BOOT} or \texttt{PLAIN\_RECEIVER}.

				If set to \texttt{DEFAULT\_BOOT}, the board will normally proceed to executing the software in \texttt{main.py}.
				When set to \texttt{PLAIN\_RECEIVER}, the board will boot 
									
				\begin{figure}[h]
					\centering
					\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
					
					% Help grid
					% \draw [help lines] (-1,1) grid (6,-6);
					
					\tikzstyle{every state}=[fill={rgb:black,1;white,5}]
					
					
					\node[state, initial]  			(s_0)                 	{$s_0$}; % START
					\node[state] 					(s_1)	[right of=s_0]	{$s_1$}; % BOOT
					\node[state, accepting]			(s_2) 	[above right of=s_1]	{$s_2$}; % MAIN LOOP
					\node[state, accepting]			(s_3) 	[below right of=s_1]	{$s_3$}; % LISTENER LOOP
					
					\path[->]
					(s_0) edge node {} (s_1)
					(s_1) edge node {} (s_2)
					(s_1) edge node {} (s_3)
					(s_2) edge [loop right] node {} ()
					(s_3) edge [loop right] node {} ();
					
					\end{tikzpicture}
					\caption{FSA for the overview of the whole system}
					\label{fsa:fsa_overview}
				\end{figure}				
			
			\subsubsection{Main}
			
			\subsubsection{Plain listener}
	
			\subsubsection{Mesh initiation}
			
			\subsubsection{Broadcast mesh information}
			
%				\begin{figure}[h]
%					\centering
%					\includegraphics[width=.7\textwidth]{resources/img/chap5/message_exchange}
%					\caption{``\textit{Open LoRa Mesh}'' architecture}
%					\label{img:openmesh_architecture}
%				\end{figure}
			
			\subsubsection{Loop}
			
			\subsubsection{Listen}
			
			\subsubsection{Message forwarding}
			
			\subsubsection{MegaSense communication}
			
			\subsubsection{Message transmission}
			
		\subsection{Supported messages}
		
	\section{LoRa addressing scheme}\label{subsec:lora_addressing}

		\textbf{\textcolor{red}{\hl{// To be completed}}}
		
		% Hardware Addressing Schemes
		
		
		%calcolare transmission times
		
	\section{Other files}
	
%		\begin{figure}[h]
%			\centering
%			\includegraphics[width=.5\textwidth]{resources/img/chap5/tree_files}
%			\caption{List of files that compose the Open LoRa Mesh project}
%			\label{img:files}
%		\end{figure}
		
	\section{Microcontroller sleep cycle}\label{sec:sleep}
	
		Most IoT devices that compose LPWANs have three main modes, or profiles: \textit{sense}, \textit{connect} and \textit{sleep}.
		Sense and connect refer respectively to gathering data from the sensors and sending it into the network, while sleep refers to a sleep-mode energy consumption where most processes in the device are halted, and some circuits may be powered down.
		It can be considered a design trade-off between functionality, size, and battery lifetime.
		
		This energy consumption profile is important because it helps maximizing the battery life, which currently is one of the most considerable bottlenecks in IoT low-power devices, as explained in Section~\ref{sec:trends}.
		
		However, in the implementation of the Open LoRa Mesh, nodes do not have such functionality implemented, since might it be the cause for network disruptions.
		
		For example, if a new node might want to join a network, but the nearest physical node is in sleep mode, there would be no possibility for the new node to request data about the network, thus wasting time and resources while waiting to the other node to come back online.
		
		Such mode could be implemented but would require an careful analysis on the evolution of the network in time, also would require a network made entirely, or mostly of static nodes.
		This thought is reviewed again in Section~\ref{sec:software_improvements}.
			
	\section{Use cases}
		
		\subsection{Mobile network}
		
			e.g. in a bike sharing environment
		
		\subsection{Fixed network}
		
			e.g. in a monitoring values of air quality inside a building
		
		\subsection{Hybrid network}
		
			e.g. integrating mobile sensors given to users with a network of fixed sensors